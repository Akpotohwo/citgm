#!/usr/bin/env node
'use strict';
require('../lib/update');  // version update check
var which = require('which');
var out = require('../lib/out');
var app = require('commander');
var util = require('util');
var child = require('child_process');
var uuid = require('node-uuid');
var async = require('async');
var path = require('path');
var url = require('url');
var npa = require('npm-package-arg');
var fs = require('fs');
var fsx = require('fs-extra');
var tar = require('tar');
var fstream = require('fstream');
var zlib = require('zlib');
var osenv = require('osenv');

// Collect the command line arguments
var image, mod, test;
app
  .version('0.1.0')
  .description(
    'Generates a Docker image that can be used to run citgm for a ' +
    'specific module')
  .arguments('<image> <module> [test]')
  .action(function(i, m, t) {
    image = i;
    mod = m;
    test = t;
  })
  .option(
    '-t, --tag <tag>', 'Docker image tag'
  )
  .option(
    '-r, --run', 'Run the docker image immediately after build')
  .option(
    '-v, --verbose', 'Verbose output')
  .option(
    '-k, --hmac <key>', 'HMAC Key for Script Verification')
  .option(
    '-l, --lookup [path]',
      'Use the lookup table. Optional [path] for alternate json file'
  )
  .option(
    '-n, --no-color', 'Turns off colorized output'
  )
  .option(
    '-s, --su', 'Allow running the tool as root.'
  )
  .option(
    '-u, --uid <uid>', 'Set the uid (posix only)'
  )
  .option(
    '-g, --gid <uid>', 'Set the gid (posix only)'
  )
  .option(
    '-d, --docker <name>', 'Alternate docker binary name'
  );

app.parse(process.argv);

var bin = app.docker || 'docker';

if (!image || !mod) {
  app.outputHelp();
  process.exit(0);
}

if (!app.su) {
  require('root-check')(); // silently downgrade if running as root...
                           // unless --su is passed
} else {
  out.warn('root', 'Running as root! Use caution!');
}

var tag = 'citgm-' + (app.tag || uuid.v4());

var detail = npa(mod);

// build the citgm CMD for the Dockerfile
function buildCmd(context, next) {
  var parts = ['citgm'];
  if (app.lookup) {
    parts.push('-l');
    if (context.lookup)
      parts.push('/usr/src/app/custom-lookup.json');
  }
  if (app.su) {
    parts.push('-s');
  }
  if (app.verbose) {
    parts.push('-v');
  }
  if (app.hmac) {
    parts.push('-h');
    parts.push('"' + app.hmac + '"');
  }
  if (app['no-color']) {
    parts.push('-n');
  }
  if (app.uid) {
    parts.push('-u');
    parts.push(app.uid);
  }
  if (app.gid) {
    parts.push('-g');
    parts.push(app.gid);
  }

  if (context.local) {
    parts.push('/usr/src/app/module.tar.gz');
  } else {
    parts.push(mod);
  }

  if (context.test)
    parts.push('/usr/src/app/custom-test');
  context.cmd = parts.join(' ');
  next(null,context);
}


// Optionally run's the docker image... uses no special arguments
function runImage(context, next) {
  if (app.run) {
    var proc = child.spawn(bin,
      [
        'run',
         context.tag
      ], {
        cwd: process.cwd(),
        stdio:[0,1,2]
      });
    proc.on('close', function(code) {
      if (code > 0) {
        out.error('failed', util.format('Docker run failed [%d]', code));
      }
      next(null,context);
    });
  } else {
    next(null,context);
  }
}

function cleanLocal(context, next) {
  fs.unlinkSync('Dockerfile');
  if (context.local)
    fs.unlinkSync('module.tar.gz');
  if (context.test)
    fs.unlinkSync('custom-test');
  if (context.lookup)
    fs.unlinkSync('custom-lookup.json');
   next(null, context);
}

function buildImage(context, next) {
  var cwd = process.cwd();
  process.chdir(context.wd);
  var proc = child.spawn('docker',
    [
      'build',
      '--rm',
      '-t', context.tag,
      '.'
    ],
    {
      cwd: context.wd,
      stdio:[0,1,2]
    }
  )
  .on('error', function(err) {
    out.error('failure', err);
    next(err);
  })
  .on('close', function(code) {
    if (code > 0) {
      next(Error('Image not created'));
      return;
    }
    process.chdir(cwd);
    out.info('created', tag);
      next(null,context);
    }
  );
}

function writeDockerfile(context, next) {
  var dest = fs.createWriteStream(path.join(context.wd, 'Dockerfile'), {encoding:'utf8'});
  dest.on('close', function() {
    next(null,context);
  });
  dest.on('error', function(err) {
    next(err);
  });
  var m = util.format('FROM %s\n',context.image);
  m += 'RUN npm install -g citgm@latest\n';
  if (context.local)
    m += 'COPY ["module.tar.gz","/usr/src/app/"]\n';
  if (context.test) {
    m += 'COPY ["custom-test","/usr/src/app/"]\n';
    //m += 'RUN chmod +x /usr/src/app/custom-test; sleep 2;\n';
  }
  if (context.lookup) {
    m += 'COPY ["custom-lookup.json", "/usr/src/app/"]\n';
  }
  m += 'CMD ' + context.cmd;
  dest.write(m);
  out.info('docker-file', m);
  dest.close();
}

function prepareCustomTest(context, next) {
  var test = context.test;
  if (test && !test.match(/^http(s)?:/i)) {
    fsx.copy(
      path.resolve(process.cwd(),test),
      path.join(context.wd,'custom-test'),
      function(err) {
      if (err) {
        next(err);
        return;
      }
      context.test = true;
      next(null,context);
    });

  } else {
    next(null, context);
  }
}

function prepareLookup(context, next) {
    if (typeof app.lookup === 'string') {
      fsx.copy(
        path.resolve(process.cwd(),app.lookup),
        path.join(context.wd,'custom-lookup.json'),
        function(err) {
          console.log('test');
        if (err) {
          next(err);
          return;
        }
        context.lookup = true;
        next(null,context);
      });
    } else {
      next(null, context);
    }
}

function packDirectory(raw, context, next) {
  function error(err) {
    next(Error(util.format('Could not pack module: ',path)));
  }
  var file = fs.createWriteStream(context.local)
    .on('error', error);
  var compressor = zlib.createGzip()
    .on('end', function() {
      file.close();
      next(null,context);
    })
    .on('error', error);
  var packer = tar.Pack({noProprietary: true}).
    on('error', error);
  fstream.Reader({path: raw, type: "Directory"}).
     on('error', error).
     pipe(packer).
     pipe(compressor).
     pipe(file);
}

function prepareLocalModule(context, next) {
  if (detail.type === 'local') {
    context.local = path.join(context.wd,'module.tar.gz');
    var raw = path.resolve(process.cwd(), detail.raw);
    out.info('prepare-local-src', raw);
    out.info('prepare-local-dest', context.local);
    fs.lstat(raw, function(err,stat) {
      if (err) {
        next(Error(util.format('Cannot access local module: %s', raw)));
        return;
      }
      if (stat.isFile()) {
        out.info('prepare-local-copy','');
        fsx.copy(raw,context.local, function(err) {
          if (err) {
            next(err);
            return;
          }
          next(null,context);
        });
      } else if (stat.isDirectory()) {
        out.info('prepare-local-pack','');
        packDirectory(raw, context, next);
      } else {
        next(Error(util.format('Cannot access localmodule: %s', raw)));
        return;
      }
    });
  } else {
    next(null, context);
  }
}

function initContext(next) {
  next(null,{
    tag:tag,
    test:test,
    image:image
  });
}

function ensureDocker(context, next) {
  which(bin, function(err,docker) {
    if (err) {
      out.error('failed', 'The docker client could not be found');
      next(Error('Aborting'));
      return;
    }
    next(null, context);
  });
}

function workingDirectory(context,next) {
  context.wd = process.cwd();
  next(null,context);
}

// launch the waterfall process...

async.waterfall([
    initContext,
    ensureDocker,
    workingDirectory,
    prepareLocalModule,
    prepareLookup,
    prepareCustomTest,
    buildCmd,
    writeDockerfile,
    buildImage,
    cleanLocal,
    runImage
  ],
  function(err, context) {
    if (err) {
      out.error('failed', err.message);
      process.exit(1);
    }
    out.info('done', context.tag);
  }
);
